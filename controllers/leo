const mongoose = require('mongoose');
const Calificacion = require('../models/Calificacion');

const crearCalificacion = async (req, res) => {
  try {
    const {
      pedidoId,
      clienteId,
      puntuacionComida,
      puntuacionServicio,
      puntuacionEntrega,
      comentario,
      calificacionProductos
    } = req.body;

  
    if (!pedidoId || !clienteId) {
      return res.status(400).json({ mensaje: 'pedidoId y clienteId son obligatorios.' });
    }

    // Verificar si ya existe calificación para ese pedido
    const existente = await Calificacion.findOne({ pedidoId });
    if (existente) {
      return res.status(400).json({ mensaje: 'Este pedido ya fue calificado.' });
    }

  
    const nueva = new Calificacion({
      pedidoId: new mongoose.Types.ObjectId(pedidoId),
      clienteId: new mongoose.Types.ObjectId(clienteId),
      puntuacionComida,
      puntuacionServicio,
      puntuacionEntrega,
      comentario,
      calificacionProductos
    });

    await nueva.save();
    res.status(201).json(nueva);
  } catch (error) {
    console.error('Error en crearCalificacion:', error);
    res.status(500).json({ mensaje: 'Error al crear calificación', error });
  }
};


//  Obtener todas las calificaciones 
const obtenerCalificaciones = async (req, res) => {
  try {
    const calificaciones = await Calificacion.find()
  //    .populate('pedidoId clienteId calificacionProductos.productoId');
    res.json(calificaciones);
  } catch (error) {
    res.status(500).json({ mensaje: 'Error al obtener calificaciones', error });
  }
};

const actualizarCalificacion = async (req, res) => {
  try {
    const { id } = req.params;
    const {
      puntuacionComida,
      puntuacionServicio,
      puntuacionEntrega,
      comentario,
      calificacionProductos
    } = req.body;

    const actualizada = await Calificacion.findByIdAndUpdate(
      id,
      {
        puntuacionComida,
        puntuacionServicio,
        puntuacionEntrega,
        comentario,
        calificacionProductos
      },
      { new: true }
    );

    if (!actualizada) {
      return res.status(404).json({ mensaje: 'Calificación no encontrada' });
    }

    res.json(actualizada);
  } catch (error) {
    res.status(500).json({ mensaje: 'Error al actualizar calificación', error });
  }
};


const eliminarCalificacion = async (req, res) => {
  try {
    const { id } = req.params;
    const eliminada = await Calificacion.findByIdAndDelete(id);

    if (!eliminada) {
      return res.status(404).json({ mensaje: 'Calificación no encontrada' });
    }

    res.json({ mensaje: 'Calificación eliminada correctamente' });
  } catch (error) {
    res.status(500).json({ mensaje: 'Error al eliminar calificación', error });
  }
};

module.exports = {
  crearCalificacion,
  obtenerCalificaciones,
  actualizarCalificacion,
  eliminarCalificacion
};

//crearCalificacion: guarda una nueva, solo si no existe ya para ese pedido.
//obtenerCalificaciones: trae todas las calificaciones.
//actualizarCalificacion: permite editar puntaje u observación.
//eliminarCalificacion: elimina una calificación por ID.
//Ahora recibe todos los campos del nuevo modelo.
//Verifica duplicados por pedidoId.
//Guarda clienteId, puntajes por tipo, comentario y array de calificaciones de productos.

const Venta = require('../models/Venta');


const crearVenta = async (req, res) => {
  try {
    console.log('📥 [POST] /api/ventas recibido');
    console.log('🟢 Body recibido:', req.body);

    const { pedidoId, clienteId, montoTotal, metodoPago } = req.body;

    // Validar campos básicos
    if (!pedidoId || !clienteId || !montoTotal || !metodoPago) {
      console.warn('⚠️ Falta algún campo obligatorio');
      return res.status(400).json({ error: 'Todos los campos son obligatorios.' });
    }

    // Buscar última venta para autoincrementar factura
    const ultimaVenta = await Venta.findOne().sort({ createdAt: -1 });

    let nuevoNumeroFactura = 1;
    if (ultimaVenta && ultimaVenta.numeroFactura) {
      const match = ultimaVenta.numeroFactura.match(/FAC-(\d+)/);
      if (match) {
        nuevoNumeroFactura = parseInt(match[1], 10) + 1;
      }
    }

    const numeroFacturaFormateado = `FAC-${nuevoNumeroFactura.toString().padStart(5, '0')}`;

    // Crear nueva venta
    const nuevaVenta = new Venta({
      pedidoId,
      clienteId,
      montoTotal,
      metodoPago: metodoPago.toUpperCase(),  // Corrige case
      numeroFactura: numeroFacturaFormateado
    });

    await nuevaVenta.save();

    console.log('✅ Venta creada correctamente:', nuevaVenta);
    res.status(201).json(nuevaVenta);

  } catch (error) {
    console.error('🔴 Error creando venta:', error);
    res.status(500).json({ error: 'Error al crear venta', detalle: error.message });
  }
};


// Obtener todas las ventas
const obtenerVentas = async (req, res) => {
  try {
    const ventas = await Venta.find();
    res.json(ventas);
  } catch (error) {
    console.error('🔴 Error obteniendo ventas:', error);
    res.status(500).json({ error: 'Error al obtener ventas' });
  }
};

// Buscar ventas por cliente
const ventasPorCliente = async (req, res) => {
  try {
    const { clienteId } = req.params;
    const ventas = await Venta.find({ clienteId });
    res.json(ventas);
  } catch (error) {
    console.error('🔴 Error buscando ventas por cliente:', error);
    res.status(500).json({ error: 'Error al buscar ventas por cliente' });
  }
};

// Filtrar ventas por fecha
const ventasPorFecha = async (req, res) => {
  try {
    const { desde, hasta } = req.query;
    const filtro = {};

    if (desde && hasta) {
      filtro.createdAt = { $gte: new Date(desde), $lte: new Date(hasta) };
    }

    const ventas = await Venta.find(filtro);
    res.json(ventas);
  } catch (error) {
    console.error('🔴 Error filtrando ventas por fecha:', error);
    res.status(500).json({ error: 'Error al filtrar ventas por fecha' });
  }
};

// Obtener total vendido
const totalVentas = async (req, res) => {
  try {
    const total = await Venta.aggregate([
      { $group: { _id: null, total: { $sum: "$montoTotal" } } }
    ]);

    res.json({ total: total[0]?.total || 0 });
  } catch (error) {
    console.error('🔴 Error calculando total de ventas:', error);
    res.status(500).json({ error: 'Error al calcular total de ventas' });
  }
};

// Procesar pago (simulado)
const procesarPago = async (req, res) => {
  try {
    const { id } = req.params;
    res.json({ mensaje: `Pago procesado para la venta con ID ${id}` });
  } catch (error) {
    console.error('🔴 Error procesando pago:', error);
    res.status(500).json({ error: 'Error al procesar pago' });
  }
};

// Obtener número de factura
const generarFactura = async (req, res) => {
  try {
    const { id } = req.params;
    const venta = await Venta.findById(id);

    if (!venta) {
      return res.status(404).json({ error: 'Venta no encontrada' });
    }

    res.json({ mensaje: 'Factura existente', numeroFactura: venta.numeroFactura });
  } catch (error) {
    console.error('🔴 Error obteniendo factura:', error);
    res.status(500).json({ error: 'Error al obtener factura' });
  }
};

// Confirmar pago
const confirmarPago = async (req, res) => {
  try {
    const { id } = req.params;

    const venta = await Venta.findByIdAndUpdate(
      id,
      { estadoPago: 'pagado' },
      { new: true }
    );

    if (!venta) {
      return res.status(404).json({ error: 'Venta no encontrada' });
    }

    res.json({ mensaje: 'Pago confirmado', venta });
  } catch (error) {
    console.error('🔴 Error confirmando pago:', error);
    res.status(500).json({ error: 'Error al confirmar pago' });
  }
};

module.exports = {
  crearVenta,
  obtenerVentas,
  ventasPorCliente,
  ventasPorFecha,
  totalVentas,
  procesarPago,
  generarFactura,
  confirmarPago
};

// Rutas
const calificacionRoutes = require('./routes/calificacion.routes');
app.use('/api/calificaciones', calificacionRoutes);
const ventaRoutes = require('./routes/venta.routes');
app.use('/api/ventas', ventaRoutes);

